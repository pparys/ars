You are a PDDL planning expert. You are given a domain, and some examples of planning problems and a valid sequences to achieve the goal. 

A plan is valid if and only if for every action in the sequence, all of its preconditions (as defined in the domain file) are satisfied in the state of the world before the action is executed.

To ensure correctness, you must reason step-by-step internally:
1.  Analyze the initial state.
2.  For each step, select an action that makes progress toward the goal.
3.  Update the world state based on the action's effects.
4.  Repeat until all goal conditions are met.

Your final output must be ONLY the valid sequence of actions.

Domain: BLOCKS

Domain Definition:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 4 Op-blocks world
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (domain BLOCKS)
  (:requirements :strips :typing)
  (:types block)
  (:predicates (on ?x - block ?y - block)
	       (ontable ?x - block)
	       (clear ?x - block)
	       (handempty)
	       (holding ?x - block)
	       )

  (:action pick-up
	     :parameters (?x - block)
	     :precondition (and (clear ?x) (ontable ?x) (handempty))
	     :effect
	     (and (not (ontable ?x))
		   (not (clear ?x))
		   (not (handempty))
		   (holding ?x)))

  (:action put-down
	     :parameters (?x - block)
	     :precondition (holding ?x)
	     :effect
	     (and (not (holding ?x))
		   (clear ?x)
		   (handempty)
		   (ontable ?x)))
  (:action stack
	     :parameters (?x - block ?y - block)
	     :precondition (and (holding ?x) (clear ?y))
	     :effect
	     (and (not (holding ?x))
		   (not (clear ?y))
		   (clear ?x)
		   (handempty)
		   (on ?x ?y)))
  (:action unstack
	     :parameters (?x - block ?y - block)
	     :precondition (and (on ?x ?y) (clear ?x) (handempty))
	     :effect
	     (and (holding ?x)
		   (clear ?y)
		   (not (clear ?x))
		   (not (handempty))
		   (not (on ?x ?y)))))

Grammar for valid actions in LARK format:
start: PLAN
PLAN: ACTION (" " ACTION)*
ACTION: "(" (("put-down" | "pick-up") " " OBJECT | ("unstack" | "stack") " " OBJECT " " OBJECT) ")"
OBJECT: /[a-e]/


Problem:
(:objects D B A C - block)
(:INIT (CLEAR C) (CLEAR A) (CLEAR B) (CLEAR D) (ONTABLE C) (ONTABLE A)
 (ONTABLE B) (ONTABLE D) (HANDEMPTY))
(:goal (AND (ON D C) (ON C B) (ON B A)))

 
Solution:
(pick-up b) (stack b a) (pick-up c) (stack c b) (pick-up d) (stack d c)

Problem:
(:objects A C D B - block)
(:INIT (CLEAR B) (ONTABLE D) (ON B C) (ON C A) (ON A D) (HANDEMPTY))
(:goal (AND (ON D C) (ON C A) (ON A B)))

 
Solution:
(unstack b c) (put-down b) (unstack c a) (put-down c) (unstack a d) (stack a b) (pick-up c) (stack c a) (pick-up d) (stack d c)

Problem:
(:objects B D C A - block)
(:INIT (CLEAR A) (CLEAR C) (CLEAR D) (ONTABLE A) (ONTABLE B) (ONTABLE D)
 (ON C B) (HANDEMPTY))
(:goal (AND (ON A B) (ON B C) (ON C D)))

 
Solution:
(unstack c b) (stack c d) (pick-up b) (stack b c) (pick-up a) (stack a b)

Problem:
(:objects E A B C F D - block)
(:INIT (CLEAR D) (CLEAR F) (ONTABLE C) (ONTABLE B) (ON D A) (ON A C) (ON F E)
 (ON E B) (HANDEMPTY))
(:goal (AND (ON C B) (ON B A) (ON A E) (ON E F) (ON F D)))

 
Solution:
(unstack d a) (put-down d) (unstack f e) (stack f d) (unstack e b) (stack e f) (unstack a c) (stack a e) (pick-up b) (stack b a) (pick-up c) (stack c b)

Problem:
(:objects A D C E B - block)
(:INIT (CLEAR B) (CLEAR E) (CLEAR C) (ONTABLE D) (ONTABLE E) (ONTABLE C)
 (ON B A) (ON A D) (HANDEMPTY))
(:goal (AND (ON D C) (ON C B) (ON B A) (ON A E)))
 

Solution: